{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { PermissionStatus, createPermissionHook, Platform } from 'expo-modules-core';\nimport ExpoLocation from \"./ExpoLocation\";\nimport { LocationAccuracy, LocationActivityType, LocationGeofencingEventType, LocationGeofencingRegionState } from \"./Location.types\";\nimport { LocationEventEmitter } from \"./LocationEventEmitter\";\nimport { setGoogleApiKey, googleGeocodeAsync, googleReverseGeocodeAsync } from \"./LocationGoogleGeocoding\";\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from \"./LocationSubscribers\";\nexport function getProviderStatusAsync() {\n  return _getProviderStatusAsync.apply(this, arguments);\n}\nfunction _getProviderStatusAsync() {\n  _getProviderStatusAsync = _asyncToGenerator(function* () {\n    return ExpoLocation.getProviderStatusAsync();\n  });\n  return _getProviderStatusAsync.apply(this, arguments);\n}\nexport function enableNetworkProviderAsync() {\n  return _enableNetworkProviderAsync.apply(this, arguments);\n}\nfunction _enableNetworkProviderAsync() {\n  _enableNetworkProviderAsync = _asyncToGenerator(function* () {\n    if (Platform.OS === 'android') {\n      return ExpoLocation.enableNetworkProviderAsync();\n    }\n  });\n  return _enableNetworkProviderAsync.apply(this, arguments);\n}\nexport function getCurrentPositionAsync() {\n  return _getCurrentPositionAsync.apply(this, arguments);\n}\nfunction _getCurrentPositionAsync() {\n  _getCurrentPositionAsync = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return ExpoLocation.getCurrentPositionAsync(options);\n  });\n  return _getCurrentPositionAsync.apply(this, arguments);\n}\nexport function getLastKnownPositionAsync() {\n  return _getLastKnownPositionAsync.apply(this, arguments);\n}\nfunction _getLastKnownPositionAsync() {\n  _getLastKnownPositionAsync = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return ExpoLocation.getLastKnownPositionAsync(options);\n  });\n  return _getLastKnownPositionAsync.apply(this, arguments);\n}\nexport function watchPositionAsync(_x, _x2) {\n  return _watchPositionAsync.apply(this, arguments);\n}\nfunction _watchPositionAsync() {\n  _watchPositionAsync = _asyncToGenerator(function* (options, callback) {\n    var watchId = LocationSubscriber.registerCallback(callback);\n    yield ExpoLocation.watchPositionImplAsync(watchId, options);\n    return {\n      remove: function remove() {\n        LocationSubscriber.unregisterCallback(watchId);\n      }\n    };\n  });\n  return _watchPositionAsync.apply(this, arguments);\n}\nexport function getHeadingAsync() {\n  return _getHeadingAsync.apply(this, arguments);\n}\nfunction _getHeadingAsync() {\n  _getHeadingAsync = _asyncToGenerator(function* () {\n    return new Promise(function () {\n      var _ref = _asyncToGenerator(function* (resolve) {\n        var tries = 0;\n        var subscription = yield watchHeadingAsync(function (heading) {\n          if (heading.accuracy > 1 || tries > 5) {\n            subscription.remove();\n            resolve(heading);\n          } else {\n            tries += 1;\n          }\n        });\n      });\n      return function (_x14) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  });\n  return _getHeadingAsync.apply(this, arguments);\n}\nexport function watchHeadingAsync(_x3) {\n  return _watchHeadingAsync.apply(this, arguments);\n}\nfunction _watchHeadingAsync() {\n  _watchHeadingAsync = _asyncToGenerator(function* (callback) {\n    var watchId = HeadingSubscriber.registerCallback(callback);\n    yield ExpoLocation.watchDeviceHeading(watchId);\n    return {\n      remove: function remove() {\n        HeadingSubscriber.unregisterCallback(watchId);\n      }\n    };\n  });\n  return _watchHeadingAsync.apply(this, arguments);\n}\nexport function geocodeAsync(_x4, _x5) {\n  return _geocodeAsync.apply(this, arguments);\n}\nfunction _geocodeAsync() {\n  _geocodeAsync = _asyncToGenerator(function* (address, options) {\n    if (typeof address !== 'string') {\n      throw new TypeError(\"Address to geocode must be a string. Got \" + address + \" instead.\");\n    }\n    if (options != null && options.useGoogleMaps || Platform.OS === 'web') {\n      return yield googleGeocodeAsync(address);\n    }\n    return yield ExpoLocation.geocodeAsync(address);\n  });\n  return _geocodeAsync.apply(this, arguments);\n}\nexport function reverseGeocodeAsync(_x6, _x7) {\n  return _reverseGeocodeAsync.apply(this, arguments);\n}\nfunction _reverseGeocodeAsync() {\n  _reverseGeocodeAsync = _asyncToGenerator(function* (location, options) {\n    if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n      throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');\n    }\n    if (options != null && options.useGoogleMaps || Platform.OS === 'web') {\n      return yield googleReverseGeocodeAsync(location);\n    }\n    return yield ExpoLocation.reverseGeocodeAsync(location);\n  });\n  return _reverseGeocodeAsync.apply(this, arguments);\n}\nexport function getPermissionsAsync() {\n  return _getPermissionsAsync.apply(this, arguments);\n}\nfunction _getPermissionsAsync() {\n  _getPermissionsAsync = _asyncToGenerator(function* () {\n    console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getForegroundPermissionsAsync()\\\" or \\\"getBackgroundPermissionsAsync()\\\" instead.\");\n    return yield ExpoLocation.getPermissionsAsync();\n  });\n  return _getPermissionsAsync.apply(this, arguments);\n}\nexport function requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = _asyncToGenerator(function* () {\n    console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestForegroundPermissionsAsync()\\\" or \\\"requestBackgroundPermissionsAsync()\\\" instead.\");\n    return yield ExpoLocation.requestPermissionsAsync();\n  });\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nexport function getForegroundPermissionsAsync() {\n  return _getForegroundPermissionsAsync.apply(this, arguments);\n}\nfunction _getForegroundPermissionsAsync() {\n  _getForegroundPermissionsAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.getForegroundPermissionsAsync();\n  });\n  return _getForegroundPermissionsAsync.apply(this, arguments);\n}\nexport function requestForegroundPermissionsAsync() {\n  return _requestForegroundPermissionsAsync.apply(this, arguments);\n}\nfunction _requestForegroundPermissionsAsync() {\n  _requestForegroundPermissionsAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.requestForegroundPermissionsAsync();\n  });\n  return _requestForegroundPermissionsAsync.apply(this, arguments);\n}\nexport var useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync\n});\nexport function getBackgroundPermissionsAsync() {\n  return _getBackgroundPermissionsAsync.apply(this, arguments);\n}\nfunction _getBackgroundPermissionsAsync() {\n  _getBackgroundPermissionsAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.getBackgroundPermissionsAsync();\n  });\n  return _getBackgroundPermissionsAsync.apply(this, arguments);\n}\nexport function requestBackgroundPermissionsAsync() {\n  return _requestBackgroundPermissionsAsync.apply(this, arguments);\n}\nfunction _requestBackgroundPermissionsAsync() {\n  _requestBackgroundPermissionsAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.requestBackgroundPermissionsAsync();\n  });\n  return _requestBackgroundPermissionsAsync.apply(this, arguments);\n}\nexport var useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync\n});\nexport function hasServicesEnabledAsync() {\n  return _hasServicesEnabledAsync.apply(this, arguments);\n}\nfunction _hasServicesEnabledAsync() {\n  _hasServicesEnabledAsync = _asyncToGenerator(function* () {\n    return yield ExpoLocation.hasServicesEnabledAsync();\n  });\n  return _hasServicesEnabledAsync.apply(this, arguments);\n}\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(\"`taskName` must be a non-empty string. Got \" + taskName + \" instead.\");\n  }\n}\nexport function isBackgroundLocationAvailableAsync() {\n  return _isBackgroundLocationAvailableAsync.apply(this, arguments);\n}\nfunction _isBackgroundLocationAvailableAsync() {\n  _isBackgroundLocationAvailableAsync = _asyncToGenerator(function* () {\n    var providerStatus = yield getProviderStatusAsync();\n    return providerStatus.backgroundModeEnabled;\n  });\n  return _isBackgroundLocationAvailableAsync.apply(this, arguments);\n}\nexport function startLocationUpdatesAsync(_x8) {\n  return _startLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _startLocationUpdatesAsync() {\n  _startLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      accuracy: LocationAccuracy.Balanced\n    };\n    _validateTaskName(taskName);\n    yield ExpoLocation.startLocationUpdatesAsync(taskName, options);\n  });\n  return _startLocationUpdatesAsync.apply(this, arguments);\n}\nexport function stopLocationUpdatesAsync(_x9) {\n  return _stopLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _stopLocationUpdatesAsync() {\n  _stopLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    yield ExpoLocation.stopLocationUpdatesAsync(taskName);\n  });\n  return _stopLocationUpdatesAsync.apply(this, arguments);\n}\nexport function hasStartedLocationUpdatesAsync(_x10) {\n  return _hasStartedLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _hasStartedLocationUpdatesAsync() {\n  _hasStartedLocationUpdatesAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n  });\n  return _hasStartedLocationUpdatesAsync.apply(this, arguments);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\nexport function startGeofencingAsync(_x11) {\n  return _startGeofencingAsync.apply(this, arguments);\n}\nfunction _startGeofencingAsync() {\n  _startGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    var regions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _validateTaskName(taskName);\n    _validateRegions(regions);\n    yield ExpoLocation.startGeofencingAsync(taskName, {\n      regions: regions\n    });\n  });\n  return _startGeofencingAsync.apply(this, arguments);\n}\nexport function stopGeofencingAsync(_x12) {\n  return _stopGeofencingAsync.apply(this, arguments);\n}\nfunction _stopGeofencingAsync() {\n  _stopGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    yield ExpoLocation.stopGeofencingAsync(taskName);\n  });\n  return _stopGeofencingAsync.apply(this, arguments);\n}\nexport function hasStartedGeofencingAsync(_x13) {\n  return _hasStartedGeofencingAsync.apply(this, arguments);\n}\nfunction _hasStartedGeofencingAsync() {\n  _hasStartedGeofencingAsync = _asyncToGenerator(function* (taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedGeofencingAsync(taskName);\n  });\n  return _hasStartedGeofencingAsync.apply(this, arguments);\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType, LocationGeofencingEventType as GeofencingEventType, LocationGeofencingRegionState as GeofencingRegionState, PermissionStatus, setGoogleApiKey };\nexport { installWebGeolocationPolyfill } from \"./GeolocationPolyfill\";\nexport * from \"./Location.types\";","map":{"version":3,"mappings":"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","names":["PermissionStatus","createPermissionHook","Platform","ExpoLocation","LocationAccuracy","LocationActivityType","LocationGeofencingEventType","LocationGeofencingRegionState","LocationEventEmitter","setGoogleApiKey","googleGeocodeAsync","googleReverseGeocodeAsync","LocationSubscriber","HeadingSubscriber","_getCurrentWatchId","getProviderStatusAsync","enableNetworkProviderAsync","OS","getCurrentPositionAsync","options","getLastKnownPositionAsync","watchPositionAsync","callback","watchId","registerCallback","watchPositionImplAsync","remove","unregisterCallback","getHeadingAsync","Promise","resolve","tries","subscription","watchHeadingAsync","heading","accuracy","watchDeviceHeading","geocodeAsync","address","TypeError","useGoogleMaps","reverseGeocodeAsync","location","latitude","longitude","getPermissionsAsync","console","warn","requestPermissionsAsync","getForegroundPermissionsAsync","requestForegroundPermissionsAsync","useForegroundPermissions","getMethod","requestMethod","getBackgroundPermissionsAsync","requestBackgroundPermissionsAsync","useBackgroundPermissions","hasServicesEnabledAsync","_validateTaskName","taskName","Error","isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","Balanced","stopLocationUpdatesAsync","hasStartedLocationUpdatesAsync","_validateRegions","regions","length","region","radius","startGeofencingAsync","stopGeofencingAsync","hasStartedGeofencingAsync","EventEmitter","Accuracy","ActivityType","GeofencingEventType","GeofencingRegionState","installWebGeolocationPolyfill"],"sources":["/Users/jamesbaker/Desktop/spark_projs/sp23-blue-FindMeFood/frontend/node_modules/expo-location/src/Location.ts"],"sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport {\n  setGoogleApiKey,\n  googleGeocodeAsync,\n  googleReverseGeocodeAsync,\n} from './LocationGoogleGeocoding';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleGeocodeAsync(address);\n  }\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleReverseGeocodeAsync(location);\n  }\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n *\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n *\n * @return A promise resolving once the task with location updates is registered.\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n *\n * @return A promise resolving as soon as the task is registered.\n *\n * @example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}