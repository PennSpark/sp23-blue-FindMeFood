{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _reactJsxRuntime = require(\"react/jsx-runtime\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar React = __importStar(require(\"react\"));\nvar MapMarker_1 = __importDefault(require(\"./MapMarker\"));\nvar MapPolyline_1 = __importDefault(require(\"./MapPolyline\"));\nvar MapPolygon_1 = __importDefault(require(\"./MapPolygon\"));\nvar Geojson = function Geojson(props) {\n  var geojson = props.geojson,\n    strokeColor = props.strokeColor,\n    fillColor = props.fillColor,\n    strokeWidth = props.strokeWidth,\n    color = props.color,\n    title = props.title,\n    image = props.image,\n    zIndex = props.zIndex,\n    _onPress = props.onPress,\n    lineCap = props.lineCap,\n    lineJoin = props.lineJoin,\n    tappable = props.tappable,\n    tracksViewChanges = props.tracksViewChanges,\n    miterLimit = props.miterLimit,\n    lineDashPhase = props.lineDashPhase,\n    lineDashPattern = props.lineDashPattern,\n    markerComponent = props.markerComponent;\n  var pointOverlays = makePointOverlays(geojson.features);\n  var lineOverlays = makeLineOverlays(geojson.features);\n  var polygonOverlays = makePolygonOverlays(geojson.features);\n  return _reactJsxRuntime.jsxs(React.Fragment, {\n    children: [pointOverlays.map(function (overlay, index) {\n      var _overlay$feature$prop;\n      var markerColor = getColor(color, overlay, 'marker-color');\n      var pointOverlayTracksViewChanges = ((_overlay$feature$prop = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop.tracksViewChanges) || tracksViewChanges;\n      return _reactJsxRuntime.jsx(MapMarker_1.default, {\n        coordinate: overlay.coordinates,\n        tracksViewChanges: pointOverlayTracksViewChanges,\n        image: image,\n        title: title,\n        pinColor: markerColor,\n        zIndex: zIndex,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        children: markerComponent\n      }, index);\n    }), lineOverlays.map(function (overlay, index) {\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _reactJsxRuntime.jsx(MapPolyline_1.default, {\n        coordinates: overlay.coordinates,\n        strokeColor: lineStrokeColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        zIndex: zIndex,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        }\n      }, index);\n    }), polygonOverlays.map(function (overlay, index) {\n      var polygonFillColor = getColor(fillColor, overlay, 'fill');\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _reactJsxRuntime.jsx(MapPolygon_1.default, {\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: lineStrokeColor,\n        fillColor: polygonFillColor,\n        strokeWidth: lineStrokeWidth,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        zIndex: zIndex\n      }, index);\n    })]\n  });\n};\nexports.default = Geojson;\nvar makePointOverlays = function makePointOverlays(features) {\n  return features.filter(isAnyPointFeature).map(function (feature) {\n    return makeCoordinatesForAnyPoint(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPoint(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n};\nvar makeLineOverlays = function makeLineOverlays(features) {\n  return features.filter(isAnyLineStringFeature).map(function (feature) {\n    return makeCoordinatesForAnyLine(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyLine(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n};\nvar makePolygonOverlays = function makePolygonOverlays(features) {\n  var multipolygons = features.filter(isMultiPolygonFeature).map(function (feature) {\n    return makeCoordinatesForMultiPolygon(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPolygon(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  var polygons = features.filter(isPolygonFeature).map(function (feature) {\n    return makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature);\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return polygons.concat(multipolygons);\n};\nvar makeOverlayForAnyPoint = function makeOverlayForAnyPoint(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\nvar makeOverlayForAnyLine = function makeOverlayForAnyLine(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\nvar makeOverlayForAnyPolygon = function makeOverlayForAnyPolygon(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined\n  };\n};\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\nvar makeCoordinatesForAnyPoint = function makeCoordinatesForAnyPoint(geometry) {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makePoint);\n};\nvar makeCoordinatesForAnyLine = function makeCoordinatesForAnyLine(geometry) {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makeLine);\n};\nvar makeCoordinatesForPolygon = function makeCoordinatesForPolygon(geometry) {\n  return geometry.coordinates.map(makeLine);\n};\nvar makeCoordinatesForMultiPolygon = function makeCoordinatesForMultiPolygon(geometry) {\n  return geometry.coordinates.map(function (p) {\n    return p.map(makeLine);\n  });\n};\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var matchArray = hex.match(/\\w\\w/g);\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n  var _matchArray$map = matchArray.map(function (x) {\n      var subColor = parseInt(x, 16);\n      if (Number.isNaN(subColor)) {\n        throw new Error('Invalid hex string');\n      }\n      return subColor;\n    }),\n    _matchArray$map2 = _slicedToArray(_matchArray$map, 3),\n    r = _matchArray$map2[0],\n    g = _matchArray$map2[1],\n    b = _matchArray$map2[2];\n  return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + alpha + \")\";\n};\nvar getColor = function getColor(prop, overlay, colorType) {\n  var _overlay$feature$prop2;\n  if (prop) {\n    return prop;\n  }\n  var color = (_overlay$feature$prop2 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop2[colorType];\n  if (color) {\n    var _overlay$feature$prop3;\n    var opacityProperty = colorType + '-opacity';\n    var alpha = (_overlay$feature$prop3 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop3[opacityProperty];\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n    return color;\n  }\n  return undefined;\n};\nvar getStrokeWidth = function getStrokeWidth(prop, overlay) {\n  var _overlay$feature$prop4;\n  if (prop) {\n    return prop;\n  }\n  return (_overlay$feature$prop4 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop4['stroke-width'];\n};\nvar isPointFeature = function isPointFeature(feature) {\n  return feature.geometry.type === 'Point';\n};\nvar isMultiPointFeature = function isMultiPointFeature(feature) {\n  return feature.geometry.type === 'MultiPoint';\n};\nvar isAnyPointFeature = function isAnyPointFeature(feature) {\n  return isPointFeature(feature) || isMultiPointFeature(feature);\n};\nvar isLineStringFeature = function isLineStringFeature(feature) {\n  return feature.geometry.type === 'LineString';\n};\nvar isMultiLineStringFeature = function isMultiLineStringFeature(feature) {\n  return feature.geometry.type === 'MultiLineString';\n};\nvar isAnyLineStringFeature = function isAnyLineStringFeature(feature) {\n  return isLineStringFeature(feature) || isMultiLineStringFeature(feature);\n};\nvar isPolygonFeature = function isPolygonFeature(feature) {\n  return feature.geometry.type === 'Polygon';\n};\nvar isMultiPolygonFeature = function isMultiPolygonFeature(feature) {\n  return feature.geometry.type === 'MultiPolygon';\n};","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","React","require","MapMarker_1","MapPolyline_1","MapPolygon_1","Geojson","props","geojson","strokeColor","fillColor","strokeWidth","color","title","image","zIndex","onPress","lineCap","lineJoin","tappable","tracksViewChanges","miterLimit","lineDashPhase","lineDashPattern","markerComponent","pointOverlays","makePointOverlays","features","lineOverlays","makeLineOverlays","polygonOverlays","makePolygonOverlays","map","overlay","index","markerColor","getColor","pointOverlayTracksViewChanges","feature","properties","coordinates","lineStrokeColor","lineStrokeWidth","getStrokeWidth","polygonFillColor","holes","default","filter","isAnyPointFeature","makeCoordinatesForAnyPoint","geometry","makeOverlayForAnyPoint","reduce","prev","curr","concat","type","isAnyLineStringFeature","makeCoordinatesForAnyLine","makeOverlayForAnyLine","multipolygons","isMultiPolygonFeature","makeCoordinatesForMultiPolygon","makeOverlayForAnyPolygon","polygons","isPolygonFeature","makeCoordinatesForPolygon","length","slice","makePoint","c","latitude","longitude","makeLine","l","p","getRgbaFromHex","hex","alpha","matchArray","match","Error","x","subColor","parseInt","Number","isNaN","r","g","b","prop","colorType","opacityProperty","isPointFeature","isMultiPointFeature","isLineStringFeature","isMultiLineStringFeature"],"sources":["/Users/jamesbaker/Desktop/spark_projs/sp23-blue-FindMeFood/frontend/node_modules/react-native-maps/lib/Geojson.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(require(\"react\"));\nconst MapMarker_1 = __importDefault(require(\"./MapMarker\"));\nconst MapPolyline_1 = __importDefault(require(\"./MapPolyline\"));\nconst MapPolygon_1 = __importDefault(require(\"./MapPolygon\"));\nconst Geojson = (props) => {\n    const { geojson, strokeColor, fillColor, strokeWidth, color, title, image, zIndex, onPress, lineCap, lineJoin, tappable, tracksViewChanges, miterLimit, lineDashPhase, lineDashPattern, markerComponent, } = props;\n    const pointOverlays = makePointOverlays(geojson.features);\n    const lineOverlays = makeLineOverlays(geojson.features);\n    const polygonOverlays = makePolygonOverlays(geojson.features);\n    return (<React.Fragment>\n      {pointOverlays.map((overlay, index) => {\n            const markerColor = getColor(color, overlay, 'marker-color');\n            const pointOverlayTracksViewChanges = overlay.feature.properties?.tracksViewChanges || tracksViewChanges;\n            return (<MapMarker_1.default key={index} coordinate={overlay.coordinates} tracksViewChanges={pointOverlayTracksViewChanges} image={image} title={title} pinColor={markerColor} zIndex={zIndex} onPress={() => onPress && onPress(overlay)}>\n            {markerComponent}\n          </MapMarker_1.default>);\n        })}\n      {lineOverlays.map((overlay, index) => {\n            const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n            const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n            return (<MapPolyline_1.default key={index} coordinates={overlay.coordinates} strokeColor={lineStrokeColor} strokeWidth={lineStrokeWidth} lineDashPhase={lineDashPhase} lineDashPattern={lineDashPattern} lineCap={lineCap} lineJoin={lineJoin} miterLimit={miterLimit} zIndex={zIndex} tappable={tappable} onPress={() => onPress && onPress(overlay)}/>);\n        })}\n      {polygonOverlays.map((overlay, index) => {\n            const polygonFillColor = getColor(fillColor, overlay, 'fill');\n            const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n            const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n            return (<MapPolygon_1.default key={index} coordinates={overlay.coordinates} holes={overlay.holes} strokeColor={lineStrokeColor} fillColor={polygonFillColor} strokeWidth={lineStrokeWidth} tappable={tappable} onPress={() => onPress && onPress(overlay)} zIndex={zIndex}/>);\n        })}\n    </React.Fragment>);\n};\nexports.default = Geojson;\nconst makePointOverlays = (features) => {\n    return features\n        .filter(isAnyPointFeature)\n        .map(feature => makeCoordinatesForAnyPoint(feature.geometry).map(coordinates => makeOverlayForAnyPoint(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'point' }));\n};\nconst makeLineOverlays = (features) => {\n    return features\n        .filter(isAnyLineStringFeature)\n        .map(feature => makeCoordinatesForAnyLine(feature.geometry).map(coordinates => makeOverlayForAnyLine(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polyline' }));\n};\nconst makePolygonOverlays = (features) => {\n    const multipolygons = features\n        .filter(isMultiPolygonFeature)\n        .map(feature => makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates => makeOverlayForAnyPolygon(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polygon' }));\n    const polygons = features\n        .filter(isPolygonFeature)\n        .map(feature => makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polygon' }));\n    return polygons.concat(multipolygons);\n};\nconst makeOverlayForAnyPoint = (coordinates, feature) => {\n    return { feature, coordinates };\n};\nconst makeOverlayForAnyLine = (coordinates, feature) => {\n    return { feature, coordinates };\n};\nconst makeOverlayForAnyPolygon = (coordinates, feature) => {\n    return {\n        feature,\n        coordinates: coordinates[0],\n        holes: coordinates.length > 1 ? coordinates.slice(1) : undefined,\n    };\n};\nconst makePoint = (c) => ({\n    latitude: c[1],\n    longitude: c[0],\n});\nconst makeLine = (l) => l.map(makePoint);\nconst makeCoordinatesForAnyPoint = (geometry) => {\n    if (geometry.type === 'Point') {\n        return [makePoint(geometry.coordinates)];\n    }\n    return geometry.coordinates.map(makePoint);\n};\nconst makeCoordinatesForAnyLine = (geometry) => {\n    if (geometry.type === 'LineString') {\n        return [makeLine(geometry.coordinates)];\n    }\n    return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForPolygon = (geometry) => {\n    return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForMultiPolygon = (geometry) => {\n    return geometry.coordinates.map(p => p.map(makeLine));\n};\nconst getRgbaFromHex = (hex, alpha = 1) => {\n    const matchArray = hex.match(/\\w\\w/g);\n    if (!matchArray || matchArray.length < 3) {\n        throw new Error('Invalid hex string');\n    }\n    const [r, g, b] = matchArray.map(x => {\n        const subColor = parseInt(x, 16);\n        if (Number.isNaN(subColor)) {\n            throw new Error('Invalid hex string');\n        }\n        return subColor;\n    });\n    return `rgba(${r},${g},${b},${alpha})`;\n};\nconst getColor = (prop, overlay, colorType) => {\n    if (prop) {\n        return prop;\n    }\n    let color = overlay.feature.properties?.[colorType];\n    if (color) {\n        const opacityProperty = colorType + '-opacity';\n        const alpha = overlay.feature.properties?.[opacityProperty];\n        if (alpha && alpha !== '0' && color[0] === '#') {\n            color = getRgbaFromHex(color, alpha);\n        }\n        return color;\n    }\n    return undefined;\n};\nconst getStrokeWidth = (prop, overlay) => {\n    if (prop) {\n        return prop;\n    }\n    return overlay.feature.properties?.['stroke-width'];\n};\n// GeoJSON.Feature type-guards\nconst isPointFeature = (feature) => feature.geometry.type === 'Point';\nconst isMultiPointFeature = (feature) => feature.geometry.type === 'MultiPoint';\nconst isAnyPointFeature = (feature) => isPointFeature(feature) || isMultiPointFeature(feature);\nconst isLineStringFeature = (feature) => feature.geometry.type === 'LineString';\nconst isMultiLineStringFeature = (feature) => feature.geometry.type === 'MultiLineString';\nconst isAnyLineStringFeature = (feature) => isLineStringFeature(feature) || isMultiLineStringFeature(feature);\nconst isPolygonFeature = (feature) => feature.geometry.type === 'Polygon';\nconst isMultiPolygonFeature = (feature) => feature.geometry.type === 'MultiPolygon';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}